{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Gift Mabokela\\\\Documents\\\\3rd year\\\\2nd Sem\\\\EPE 321\\\\Practical\\\\foodsave-hub\\\\client\\\\src\\\\communication\\\\Components\\\\ChatContext.jsx\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect } from 'react';\nimport { getStakeholderId, getUserChats, markChatRead as markChatReadService, updateChatHistory, markDelivered as markDeliveredService } from '../services/chatServices';\nimport { io } from 'socket.io-client';\n\n/* Author: Lethabo Mazui\n   Event: Sprint 1\n   LatestUpdate: Created ChatContext\n   Description: Provides context for chat state, encryption, websocket events, and helper functions\n*/\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChatContext = /*#__PURE__*/createContext();\n\n// ----------------------------\n// Base64 helpers\n// ----------------------------\n/* Author: Lethabo Mazui\n   LatestUpdate: Added buf/base64 conversion\n   Description: Converts ArrayBuffer to base64 string\n*/\nfunction bufToBase64(buf) {\n  const bytes = new Uint8Array(buf);\n  let binary = '';\n  for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);\n  return btoa(binary);\n}\n\n/* Author: Lethabo Mazui\n   LatestUpdate: Added base64 to ArrayBuffer conversion\n   Description: Converts base64 string to ArrayBuffer\n*/\nfunction base64ToBuf(b64) {\n  const binary = atob(b64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);\n  return bytes.buffer;\n}\n\n// ----------------------------\n// AES-GCM encryption helpers\n// ----------------------------\n/* Author: Lethabo Mazui\n   LatestUpdate: Added encryptWithKey function\n   Description: Encrypts plaintext with AES-GCM using a derived key\n*/\nasync function encryptWithKey(key, plaintext) {\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n  const encoded = new TextEncoder().encode(plaintext);\n  const cipherBuffer = await crypto.subtle.encrypt({\n    name: 'AES-GCM',\n    iv\n  }, key, encoded);\n  return {\n    ciphertextB64: bufToBase64(cipherBuffer),\n    ivB64: bufToBase64(iv)\n  };\n}\n\n// ----------------------------\n// Key derivation\n// ----------------------------\nconst keyCache = new Map();\n/* Author: Lethabo Mazui\n   LatestUpdate: Added deriveKey\n   Description: Deterministically derives AES-GCM key per donationId\n*/\nasync function deriveKey(donationId) {\n  if (keyCache.has(donationId)) return keyCache.get(donationId);\n  const enc = new TextEncoder();\n  const keyMaterial = await crypto.subtle.importKey(\"raw\", enc.encode(donationId), \"PBKDF2\", false, [\"deriveKey\"]);\n  const key = await crypto.subtle.deriveKey({\n    name: \"PBKDF2\",\n    salt: enc.encode(\"chat-e2ee\"),\n    iterations: 100000,\n    hash: \"SHA-256\"\n  }, keyMaterial, {\n    name: \"AES-GCM\",\n    length: 256\n  }, false, [\"encrypt\", \"decrypt\"]);\n  keyCache.set(donationId, key);\n  return key;\n}\n\n// ----------------------------\n// Decryption helper\n// ----------------------------\nconst ivCache = new Map();\n/* Author: Lethabo Mazui\n   LatestUpdate: Added decryptMessage\n   Description: Safely decrypts message using cached key + IV\n*/\nasync function decryptMessage(msg) {\n  if (!msg.chathistory || !msg.iv || !msg.donationid) return {\n    ...msg,\n    chathistory: \"\"\n  };\n  try {\n    let key = await deriveKey(msg.donationid);\n    if (!ivCache.has(msg.chatid)) ivCache.set(msg.chatid, msg.iv);\n    const rawCipher = base64ToBuf(msg.chathistory);\n    const rawIv = base64ToBuf(ivCache.get(msg.chatid));\n    const decrypted = await crypto.subtle.decrypt({\n      name: \"AES-GCM\",\n      iv: rawIv\n    }, key, rawCipher);\n    return {\n      ...msg,\n      chathistory: new TextDecoder().decode(decrypted)\n    };\n  } catch (err) {\n    console.error(`❌ Failed to decrypt message ${msg.chatid}:`, err);\n    return {\n      ...msg,\n      chathistory: \"[decryption error]\"\n    };\n  }\n}\n\n// ----------------------------\n// ChatProvider component\n// ----------------------------\nexport const ChatProvider = ({\n  children,\n  currentUserEmail,\n  currentUserId: initialUserId\n}) => {\n  _s();\n  const [channels, setChannels] = useState([]);\n  const [currentUserId, setCurrentUserId] = useState(initialUserId || null);\n  const [socket, setSocket] = useState(null);\n  const [onlineUsers, setOnlineUsers] = useState(new Set());\n  const readCache = new Set();\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: Fetch stakeholderId\n     Description: Determines current userId if not already set\n  */\n  useEffect(() => {\n    if (!currentUserEmail || currentUserId) return;\n    (async () => {\n      try {\n        const response = await getStakeholderId(currentUserEmail);\n        if (!(response !== null && response !== void 0 && response.stakeholderid)) return;\n        setCurrentUserId(response.stakeholderid);\n      } catch (err) {\n        console.error('❌ Error fetching stakeholderId:', err);\n      }\n    })();\n  }, [currentUserEmail, currentUserId]);\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: WebSocket connection\n     Description: Sets up socket.io for real-time messages and online status tracking\n  */\n  useEffect(() => {\n    if (!currentUserId) return;\n    const newSocket = io(process.env.REACT_APP_BACKEND_URL, {\n      query: {\n        userId: currentUserId\n      }\n    });\n    setSocket(newSocket);\n    newSocket.emit('joinUser', {\n      userId: currentUserId\n    });\n    newSocket.on('newMessage', async msg => {\n      const decrypted = await decryptMessage(msg);\n      setChannels(prev => prev.some(m => m.chatid === msg.chatid) ? prev : [...prev, decrypted]);\n    });\n    newSocket.on('messageDelivered', ({\n      chatid\n    }) => {\n      setChannels(prev => prev.map(msg => msg.chatid === chatid ? {\n        ...msg,\n        delivered: true\n      } : msg));\n    });\n    newSocket.on('messageRead', ({\n      donationid,\n      senderId\n    }) => {\n      setChannels(prev => prev.map(msg => msg.donationid === donationid && msg.senderid !== senderId ? {\n        ...msg,\n        readreceipts: true\n      } : msg));\n    });\n    newSocket.on('onlineUsers', onlineIds => setOnlineUsers(new Set(onlineIds)));\n    newSocket.on('userConnected', userId => setOnlineUsers(prev => new Set(prev).add(userId)));\n    newSocket.on('userDisconnected', userId => setOnlineUsers(prev => {\n      const updated = new Set(prev);\n      updated.delete(userId);\n      return updated;\n    }));\n    return () => {\n      newSocket.disconnect();\n      newSocket.off('onlineUsers');\n      newSocket.off('userConnected');\n      newSocket.off('userDisconnected');\n    };\n  }, [currentUserId]);\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: Polling getUserChats\n     Description: Periodically fetches user chats and decrypts messages\n  */\n  useEffect(() => {\n    if (!currentUserEmail || !currentUserId) return;\n    const fetchChats = async () => {\n      try {\n        const data = await getUserChats(currentUserEmail);\n        if (!(data !== null && data !== void 0 && data.length)) return;\n        const decryptedData = await Promise.all(data.map(decryptMessage));\n        setChannels(prev => {\n          const existingIds = prev.map(m => m.chatid);\n          const newMessages = decryptedData.filter(m => !existingIds.includes(m.chatid));\n          return [...prev, ...newMessages];\n        });\n      } catch (err) {\n        console.error('❌ Polling getUserChats error:', err);\n      }\n    };\n    fetchChats();\n    const intervalId = setInterval(fetchChats, 5000);\n    return () => clearInterval(intervalId);\n  }, [currentUserEmail, currentUserId]);\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: Add new message\n     Description: Encrypts, sends, stores locally, and emits via socket\n  */\n  const addMessage = async (senderId, text, donationId, message_timestamp) => {\n    if (!donationId || !senderId || !text.trim()) return;\n\n    // Get current UTC time and add 2 hours\n    // const now = new Date(); \n    // const utcPlus2 = new Date(now.getTime() + 2 * 60 * 60 * 1000);\n    // const timestamp = utcPlus2.toISOString();\n\n    const localMessage = {\n      chatid: `temp-${Date.now()}`,\n      donationid: donationId,\n      senderid: senderId,\n      chathistory: text,\n      message_timestamp: message_timestamp,\n      readreceipts: false,\n      delivered: false\n    };\n    setChannels(prev => [...prev, localMessage]);\n    try {\n      const key = await deriveKey(donationId);\n      const {\n        ciphertextB64,\n        ivB64\n      } = await encryptWithKey(key, text);\n      ivCache.set(localMessage.chatid, ivB64);\n      const saved = await updateChatHistory(donationId, senderId, ciphertextB64, ivB64);\n      const decryptedText = await decryptMessage(saved);\n      setChannels(prev => prev.map(msg => msg.chatid === localMessage.chatid ? decryptedText : msg));\n      if (socket) socket.emit('newMessage', saved);\n    } catch (err) {\n      console.error('❌ addMessage backend error:', err);\n    }\n  };\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: Mark chat read\n     Description: Marks all messages for a donation as read locally and via backend\n  */\n  const markChatRead = async donationId => {\n    if (!donationId || !currentUserId || readCache.has(donationId)) return;\n    const hasUnread = channels.some(msg => msg.donationid === donationId && msg.senderid !== currentUserId && !msg.readreceipts);\n    if (!hasUnread) return;\n    readCache.add(donationId);\n    setChannels(prev => prev.map(msg => msg.donationid === donationId && msg.senderid !== currentUserId ? {\n      ...msg,\n      readreceipts: true\n    } : msg));\n    try {\n      await markChatReadService(donationId, currentUserId);\n      if (socket) socket.emit('messageRead', {\n        donationId,\n        senderId: currentUserId\n      });\n    } catch (err) {\n      console.error('❌ markChatRead backend error:', err);\n    }\n  };\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: Mark chat delivered\n     Description: Marks all messages for a donation as delivered locally and via backend\n  */\n  const markDelivered = async donationId => {\n    if (!donationId || !currentUserId) return;\n    setChannels(prev => prev.map(msg => msg.donationid === donationId && msg.senderid !== currentUserId ? {\n      ...msg,\n      delivered: true\n    } : msg));\n    try {\n      const result = await markDeliveredService(donationId, currentUserId);\n      if (socket) socket.emit('messageDelivered', {\n        donationId,\n        userId: currentUserId\n      });\n      return result;\n    } catch (err) {\n      console.error('❌ markDelivered backend error:', err);\n    }\n  };\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: Unread count helper\n     Description: Returns number of unread messages for a donation\n  */\n  const getUnreadCount = donationId => {\n    if (!currentUserId) return 0;\n    return channels.filter(msg => msg.donationid === donationId && msg.senderid !== currentUserId && !msg.readreceipts && msg.delivered).length;\n  };\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: {\n      channels,\n      setChannels,\n      markChatRead,\n      markDelivered,\n      addMessage,\n      getUnreadCount,\n      currentUserEmail,\n      currentUserId,\n      socket,\n      onlineUsers\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 291,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatProvider, \"FCqxxo56Ll+yMY10xtCS/xRR7ts=\");\n_c = ChatProvider;\nexport default ChatContext;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","getStakeholderId","getUserChats","markChatRead","markChatReadService","updateChatHistory","markDelivered","markDeliveredService","io","jsxDEV","_jsxDEV","ChatContext","bufToBase64","buf","bytes","Uint8Array","binary","i","byteLength","String","fromCharCode","btoa","base64ToBuf","b64","atob","length","charCodeAt","buffer","encryptWithKey","key","plaintext","iv","crypto","getRandomValues","encoded","TextEncoder","encode","cipherBuffer","subtle","encrypt","name","ciphertextB64","ivB64","keyCache","Map","deriveKey","donationId","has","get","enc","keyMaterial","importKey","salt","iterations","hash","set","ivCache","decryptMessage","msg","chathistory","donationid","chatid","rawCipher","rawIv","decrypted","decrypt","TextDecoder","decode","err","console","error","ChatProvider","children","currentUserEmail","currentUserId","initialUserId","_s","channels","setChannels","setCurrentUserId","socket","setSocket","onlineUsers","setOnlineUsers","Set","readCache","response","stakeholderid","newSocket","process","env","REACT_APP_BACKEND_URL","query","userId","emit","on","prev","some","m","map","delivered","senderId","senderid","readreceipts","onlineIds","add","updated","delete","disconnect","off","fetchChats","data","decryptedData","Promise","all","existingIds","newMessages","filter","includes","intervalId","setInterval","clearInterval","addMessage","text","message_timestamp","trim","localMessage","Date","now","saved","decryptedText","hasUnread","result","getUnreadCount","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Gift Mabokela/Documents/3rd year/2nd Sem/EPE 321/Practical/foodsave-hub/client/src/communication/Components/ChatContext.jsx"],"sourcesContent":["import React, { createContext, useState, useEffect } from 'react';\nimport {\n  getStakeholderId,\n  getUserChats,\n  markChatRead as markChatReadService,\n  updateChatHistory,\n  markDelivered as markDeliveredService\n} from '../services/chatServices';\nimport { io } from 'socket.io-client';\n\n/* Author: Lethabo Mazui\n   Event: Sprint 1\n   LatestUpdate: Created ChatContext\n   Description: Provides context for chat state, encryption, websocket events, and helper functions\n*/\nconst ChatContext = createContext();\n\n// ----------------------------\n// Base64 helpers\n// ----------------------------\n/* Author: Lethabo Mazui\n   LatestUpdate: Added buf/base64 conversion\n   Description: Converts ArrayBuffer to base64 string\n*/\nfunction bufToBase64(buf) {\n  const bytes = new Uint8Array(buf);\n  let binary = '';\n  for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);\n  return btoa(binary);\n}\n\n/* Author: Lethabo Mazui\n   LatestUpdate: Added base64 to ArrayBuffer conversion\n   Description: Converts base64 string to ArrayBuffer\n*/\nfunction base64ToBuf(b64) {\n  const binary = atob(b64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);\n  return bytes.buffer;\n}\n\n// ----------------------------\n// AES-GCM encryption helpers\n// ----------------------------\n/* Author: Lethabo Mazui\n   LatestUpdate: Added encryptWithKey function\n   Description: Encrypts plaintext with AES-GCM using a derived key\n*/\nasync function encryptWithKey(key, plaintext) {\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n  const encoded = new TextEncoder().encode(plaintext);\n  const cipherBuffer = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, encoded);\n  return { ciphertextB64: bufToBase64(cipherBuffer), ivB64: bufToBase64(iv) };\n}\n\n// ----------------------------\n// Key derivation\n// ----------------------------\nconst keyCache = new Map();\n/* Author: Lethabo Mazui\n   LatestUpdate: Added deriveKey\n   Description: Deterministically derives AES-GCM key per donationId\n*/\nasync function deriveKey(donationId) {\n  if (keyCache.has(donationId)) return keyCache.get(donationId);\n  const enc = new TextEncoder();\n  const keyMaterial = await crypto.subtle.importKey(\n    \"raw\",\n    enc.encode(donationId),\n    \"PBKDF2\",\n    false,\n    [\"deriveKey\"]\n  );\n  const key = await crypto.subtle.deriveKey(\n    { name: \"PBKDF2\", salt: enc.encode(\"chat-e2ee\"), iterations: 100000, hash: \"SHA-256\" },\n    keyMaterial,\n    { name: \"AES-GCM\", length: 256 },\n    false,\n    [\"encrypt\", \"decrypt\"]\n  );\n  keyCache.set(donationId, key);\n  return key;\n}\n\n// ----------------------------\n// Decryption helper\n// ----------------------------\nconst ivCache = new Map();\n/* Author: Lethabo Mazui\n   LatestUpdate: Added decryptMessage\n   Description: Safely decrypts message using cached key + IV\n*/\nasync function decryptMessage(msg) {\n  if (!msg.chathistory || !msg.iv || !msg.donationid) return { ...msg, chathistory: \"\" };\n  try {\n    let key = await deriveKey(msg.donationid);\n\n    if (!ivCache.has(msg.chatid)) ivCache.set(msg.chatid, msg.iv);\n    const rawCipher = base64ToBuf(msg.chathistory);\n    const rawIv = base64ToBuf(ivCache.get(msg.chatid));\n\n    const decrypted = await crypto.subtle.decrypt({ name: \"AES-GCM\", iv: rawIv }, key, rawCipher);\n    return { ...msg, chathistory: new TextDecoder().decode(decrypted) };\n  } catch (err) {\n    console.error(`❌ Failed to decrypt message ${msg.chatid}:`, err);\n    return { ...msg, chathistory: \"[decryption error]\" };\n  }\n}\n\n// ----------------------------\n// ChatProvider component\n// ----------------------------\nexport const ChatProvider = ({ children, currentUserEmail, currentUserId: initialUserId }) => {\n  const [channels, setChannels] = useState([]);\n  const [currentUserId, setCurrentUserId] = useState(initialUserId || null);\n  const [socket, setSocket] = useState(null);\n  const [onlineUsers, setOnlineUsers] = useState(new Set());\n  const readCache = new Set();\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: Fetch stakeholderId\n     Description: Determines current userId if not already set\n  */\n  useEffect(() => {\n    if (!currentUserEmail || currentUserId) return;\n    (async () => {\n      try {\n        const response = await getStakeholderId(currentUserEmail);\n        if (!response?.stakeholderid) return;\n        setCurrentUserId(response.stakeholderid);\n      } catch (err) {\n        console.error('❌ Error fetching stakeholderId:', err);\n      }\n    })();\n  }, [currentUserEmail, currentUserId]);\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: WebSocket connection\n     Description: Sets up socket.io for real-time messages and online status tracking\n  */\n  useEffect(() => {\n    if (!currentUserId) return;\n    const newSocket = io(process.env.REACT_APP_BACKEND_URL, { query: { userId: currentUserId } });\n    setSocket(newSocket);\n\n    newSocket.emit('joinUser', { userId: currentUserId });\n\n    newSocket.on('newMessage', async (msg) => {\n      const decrypted = await decryptMessage(msg);\n      setChannels(prev => prev.some(m => m.chatid === msg.chatid) ? prev : [...prev, decrypted]);\n    });\n\n    newSocket.on('messageDelivered', ({ chatid }) => {\n      setChannels(prev => prev.map(msg => msg.chatid === chatid ? { ...msg, delivered: true } : msg));\n    });\n\n    newSocket.on('messageRead', ({ donationid, senderId }) => {\n      setChannels(prev => prev.map(msg => msg.donationid === donationid && msg.senderid !== senderId ? { ...msg, readreceipts: true } : msg));\n    });\n\n    newSocket.on('onlineUsers', (onlineIds) => setOnlineUsers(new Set(onlineIds)));\n    newSocket.on('userConnected', (userId) => setOnlineUsers(prev => new Set(prev).add(userId)));\n    newSocket.on('userDisconnected', (userId) => setOnlineUsers(prev => {\n      const updated = new Set(prev);\n      updated.delete(userId);\n      return updated;\n    }));\n\n    return () => {\n      newSocket.disconnect();\n      newSocket.off('onlineUsers');\n      newSocket.off('userConnected');\n      newSocket.off('userDisconnected');\n    };\n  }, [currentUserId]);\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: Polling getUserChats\n     Description: Periodically fetches user chats and decrypts messages\n  */\n  useEffect(() => {\n    if (!currentUserEmail || !currentUserId) return;\n\n    const fetchChats = async () => {\n      try {\n        const data = await getUserChats(currentUserEmail);\n        if (!data?.length) return;\n        const decryptedData = await Promise.all(data.map(decryptMessage));\n\n        setChannels(prev => {\n          const existingIds = prev.map(m => m.chatid);\n          const newMessages = decryptedData.filter(m => !existingIds.includes(m.chatid));\n          return [...prev, ...newMessages];\n        });\n      } catch (err) {\n        console.error('❌ Polling getUserChats error:', err);\n      }\n    };\n\n    fetchChats();\n    const intervalId = setInterval(fetchChats, 5000);\n    return () => clearInterval(intervalId);\n  }, [currentUserEmail, currentUserId]);\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: Add new message\n     Description: Encrypts, sends, stores locally, and emits via socket\n  */\n  const addMessage = async (senderId, text, donationId, message_timestamp) => {\n    if (!donationId || !senderId || !text.trim()) return;\n\n    // Get current UTC time and add 2 hours\n    // const now = new Date(); \n    // const utcPlus2 = new Date(now.getTime() + 2 * 60 * 60 * 1000);\n    // const timestamp = utcPlus2.toISOString();\n\n    const localMessage = {\n      chatid: `temp-${Date.now()}`,\n      donationid: donationId,\n      senderid: senderId,\n      chathistory: text,\n      message_timestamp:message_timestamp,\n      readreceipts: false,\n      delivered: false\n    };\n\n    setChannels(prev => [...prev, localMessage]);\n\n    try {\n      const key = await deriveKey(donationId);\n      const { ciphertextB64, ivB64 } = await encryptWithKey(key, text);\n      ivCache.set(localMessage.chatid, ivB64);\n      const saved = await updateChatHistory(donationId, senderId, ciphertextB64, ivB64);\n      const decryptedText = await decryptMessage(saved);\n      setChannels(prev => prev.map(msg => msg.chatid === localMessage.chatid ? decryptedText : msg));\n\n      if (socket) socket.emit('newMessage', saved);\n    } catch (err) {\n      console.error('❌ addMessage backend error:', err);\n    }\n  };\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: Mark chat read\n     Description: Marks all messages for a donation as read locally and via backend\n  */\n  const markChatRead = async (donationId) => {\n    if (!donationId || !currentUserId || readCache.has(donationId)) return;\n\n    const hasUnread = channels.some(msg => msg.donationid === donationId && msg.senderid !== currentUserId && !msg.readreceipts);\n    if (!hasUnread) return;\n\n    readCache.add(donationId);\n    setChannels(prev => prev.map(msg => msg.donationid === donationId && msg.senderid !== currentUserId ? { ...msg, readreceipts: true } : msg));\n\n    try {\n      await markChatReadService(donationId, currentUserId);\n      if (socket) socket.emit('messageRead', { donationId, senderId: currentUserId });\n    } catch (err) {\n      console.error('❌ markChatRead backend error:', err);\n    }\n  };\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: Mark chat delivered\n     Description: Marks all messages for a donation as delivered locally and via backend\n  */\n  const markDelivered = async (donationId) => {\n    if (!donationId || !currentUserId) return;\n    setChannels(prev => prev.map(msg => msg.donationid === donationId && msg.senderid !== currentUserId ? { ...msg, delivered: true } : msg));\n    try {\n      const result = await markDeliveredService(donationId, currentUserId);\n      if (socket) socket.emit('messageDelivered', { donationId, userId: currentUserId });\n      return result;\n    } catch (err) {\n      console.error('❌ markDelivered backend error:', err);\n    }\n  };\n\n  /* Author: Lethabo Mazui\n     LatestUpdate: Unread count helper\n     Description: Returns number of unread messages for a donation\n  */\n  const getUnreadCount = (donationId) => {\n    if (!currentUserId) return 0;\n    return channels.filter(msg => msg.donationid === donationId && msg.senderid !== currentUserId && !msg.readreceipts && msg.delivered).length;\n  };\n\n  return (\n    <ChatContext.Provider value={{\n      channels,\n      setChannels,\n      markChatRead,\n      markDelivered,\n      addMessage,\n      getUnreadCount,\n      currentUserEmail,\n      currentUserId,\n      socket,\n      onlineUsers\n    }}>\n      {children}\n    </ChatContext.Provider>\n  );\n};\n\nexport default ChatContext;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
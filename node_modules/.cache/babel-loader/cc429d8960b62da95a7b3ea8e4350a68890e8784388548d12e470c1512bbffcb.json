{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\letha\\\\Downloads\\\\EPE Semester Project\\\\foodsave-hub\\\\client\\\\src\\\\communication\\\\Components\\\\ChatContext.jsx\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect } from 'react';\nimport { getStakeholderId, getUserChats, markChatRead as markChatReadService, updateChatHistory, markDelivered as markDeliveredService } from '../services/chatServices';\nimport { io } from 'socket.io-client';\n\n/* Author: Lethabo Mazui\r\n   Event: Sprint 1\r\n   LatestUpdate: Created ChatContext\r\n   Description: Provides context for chat state, encryption, websocket events, and helper functions\r\n*/\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChatContext = /*#__PURE__*/createContext();\n\n// ----------------------------\n// Base64 helpers\n// ----------------------------\n/* Author: Lethabo Mazui\r\n   LatestUpdate: Added buf/base64 conversion\r\n   Description: Converts ArrayBuffer to base64 string\r\n*/\nfunction bufToBase64(buf) {\n  const bytes = new Uint8Array(buf);\n  let binary = '';\n  for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);\n  return btoa(binary);\n}\n\n/* Author: Lethabo Mazui\r\n   LatestUpdate: Added base64 to ArrayBuffer conversion\r\n   Description: Converts base64 string to ArrayBuffer\r\n*/\nfunction base64ToBuf(b64) {\n  const binary = atob(b64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);\n  return bytes.buffer;\n}\n\n// ----------------------------\n// AES-GCM encryption helpers\n// ----------------------------\n/* Author: Lethabo Mazui\r\n   LatestUpdate: Added encryptWithKey function\r\n   Description: Encrypts plaintext with AES-GCM using a derived key\r\n*/\nasync function encryptWithKey(key, plaintext) {\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n  const encoded = new TextEncoder().encode(plaintext);\n  const cipherBuffer = await crypto.subtle.encrypt({\n    name: 'AES-GCM',\n    iv\n  }, key, encoded);\n  return {\n    ciphertextB64: bufToBase64(cipherBuffer),\n    ivB64: bufToBase64(iv)\n  };\n}\n\n// ----------------------------\n// Key derivation\n// ----------------------------\nconst keyCache = new Map();\n/* Author: Lethabo Mazui\r\n   LatestUpdate: Added deriveKey\r\n   Description: Deterministically derives AES-GCM key per donationId\r\n*/\nasync function deriveKey(donationId) {\n  if (keyCache.has(donationId)) return keyCache.get(donationId);\n  const enc = new TextEncoder();\n  const keyMaterial = await crypto.subtle.importKey(\"raw\", enc.encode(donationId), \"PBKDF2\", false, [\"deriveKey\"]);\n  const key = await crypto.subtle.deriveKey({\n    name: \"PBKDF2\",\n    salt: enc.encode(\"chat-e2ee\"),\n    iterations: 100000,\n    hash: \"SHA-256\"\n  }, keyMaterial, {\n    name: \"AES-GCM\",\n    length: 256\n  }, false, [\"encrypt\", \"decrypt\"]);\n  keyCache.set(donationId, key);\n  return key;\n}\n\n// ----------------------------\n// Decryption helper\n// ----------------------------\nconst ivCache = new Map();\n/* Author: Lethabo Mazui\r\n   LatestUpdate: Added decryptMessage\r\n   Description: Safely decrypts message using cached key + IV\r\n*/\nasync function decryptMessage(msg) {\n  console.log('Attempting to decrypt message:', msg.chatid);\n  console.log('Raw newMessage from server:', msg);\n  if (!msg.chathistory || !msg.iv || !msg.donationid) {\n    console.log('Missing required fields for decryption');\n    return {\n      ...msg,\n      chathistory: \"\"\n    };\n  }\n  try {\n    let key = await deriveKey(msg.donationid);\n    console.log('Key derived for donation:', msg.donationid);\n    if (!ivCache.has(msg.chatid)) ivCache.set(msg.chatid, msg.iv);\n    const rawCipher = base64ToBuf(msg.chathistory);\n    const rawIv = base64ToBuf(ivCache.get(msg.chatid));\n    console.log('Decrypting with IV:', msg.iv);\n    const decrypted = await crypto.subtle.decrypt({\n      name: \"AES-GCM\",\n      iv: rawIv\n    }, key, rawCipher);\n    const decryptedText = new TextDecoder().decode(decrypted);\n    console.log('Successfully decrypted:', decryptedText);\n    return {\n      ...msg,\n      chathistory: decryptedText\n    };\n  } catch (err) {\n    console.error(` Failed to decrypt message ${msg.chatid}:`, err);\n    return {\n      ...msg,\n      chathistory: \"[decryption error]\"\n    };\n  }\n}\n\n// ----------------------------\n// ChatProvider component\n// ----------------------------\nexport const ChatProvider = ({\n  children,\n  currentUserEmail,\n  currentUserId: initialUserId\n}) => {\n  _s();\n  const [channels, setChannels] = useState([]);\n  const [currentUserId, setCurrentUserId] = useState(initialUserId || null);\n  const [socket, setSocket] = useState(null);\n  const [onlineUsers, setOnlineUsers] = useState(new Set());\n  const readCache = new Set();\n\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: Fetch stakeholderId\r\n     Description: Determines current userId if not already set\r\n  */\n  useEffect(() => {\n    if (!currentUserEmail || currentUserId) return;\n    (async () => {\n      try {\n        const response = await getStakeholderId(currentUserEmail);\n        if (!(response !== null && response !== void 0 && response.stakeholderid)) return;\n        setCurrentUserId(response.stakeholderid);\n      } catch (err) {\n        console.error(' Error fetching stakeholderId:', err);\n      }\n    })();\n  }, [currentUserEmail, currentUserId]);\n\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: WebSocket connection\r\n     Description: Sets up socket.io for real-time messages and online status tracking\r\n  */\n  useEffect(() => {\n    if (!currentUserId) return;\n    const newSocket = io(process.env.REACT_APP_BACKEND_URL, {\n      query: {\n        userId: currentUserId\n      }\n    });\n    setSocket(newSocket);\n    newSocket.emit('joinUser', {\n      userId: currentUserId\n    });\n    newSocket.on('newMessage', async msg => {\n      const decrypted = await decryptMessage(msg);\n      setChannels(prev => prev.some(m => m.chatid === msg.chatid) ? prev : [...prev, decrypted]);\n    });\n    newSocket.on('messageDelivered', ({\n      chatid\n    }) => {\n      setChannels(prev => prev.map(msg => msg.chatid === chatid ? {\n        ...msg,\n        delivered: true\n      } : msg));\n    });\n    newSocket.on('messageRead', ({\n      donationid,\n      senderId\n    }) => {\n      setChannels(prev => prev.map(msg => msg.donationid === donationid && msg.senderid !== senderId ? {\n        ...msg,\n        readreceipts: true\n      } : msg));\n    });\n    newSocket.on('onlineUsers', onlineIds => setOnlineUsers(new Set(onlineIds)));\n    newSocket.on('userConnected', userId => setOnlineUsers(prev => new Set(prev).add(userId)));\n    newSocket.on('userDisconnected', userId => setOnlineUsers(prev => {\n      const updated = new Set(prev);\n      updated.delete(userId);\n      return updated;\n    }));\n    return () => {\n      newSocket.disconnect();\n      newSocket.off('onlineUsers');\n      newSocket.off('userConnected');\n      newSocket.off('userDisconnected');\n    };\n  }, [currentUserId]);\n\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: Polling getUserChats\r\n     Description: Periodically fetches user chats and decrypts messages\r\n  */\n  useEffect(() => {\n    if (!currentUserEmail || !currentUserId) return;\n    const fetchChats = async () => {\n      try {\n        const data = await getUserChats(currentUserEmail);\n        if (!(data !== null && data !== void 0 && data.length)) return;\n        const decryptedData = await Promise.all(data.map(decryptMessage));\n        setChannels(prev => {\n          const existingIds = prev.map(m => m.chatid);\n          const newMessages = decryptedData.filter(m => !existingIds.includes(m.chatid));\n          return [...prev, ...newMessages];\n        });\n      } catch (err) {\n        console.error(' Polling getUserChats error:', err);\n      }\n    };\n    fetchChats();\n    const intervalId = setInterval(fetchChats, 5000);\n    return () => clearInterval(intervalId);\n  }, [currentUserEmail, currentUserId]);\n\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: Add new message\r\n     Description: Encrypts, sends, stores locally, and emits via socket\r\n  */\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: Fixed IV handling in addMessage\r\n     Description: Derives key, encrypts once, attaches IV, and syncs with backend\r\n  */\n  const addMessage = async (senderId, text, donationId, message_timestamp) => {\n    if (!donationId || !senderId || !text.trim()) return;\n    try {\n      // 1. Derive key first\n      const key = await deriveKey(donationId);\n\n      // 2. Encrypt message (ciphertext + iv)\n      const {\n        ciphertextB64,\n        ivB64\n      } = await encryptWithKey(key, text);\n\n      // 3. Create temporary local message (shows instantly in UI)\n      const localMessage = {\n        chatid: `temp-${Date.now()}`,\n        donationid: donationId,\n        senderid: senderId,\n        chathistory: text,\n        // plain text for local display\n        iv: ivB64,\n        // include generated IV immediately\n        message_timestamp,\n        readreceipts: false,\n        delivered: false\n      };\n\n      // 4. Cache the IV for this chatid\n      ivCache.set(localMessage.chatid, ivB64);\n\n      // 5. Add localMessage to UI immediately\n      setChannels(prev => [...prev, localMessage]);\n\n      // 6. Save encrypted message to backend\n      const saved = await updateChatHistory(donationId, senderId, ciphertextB64, ivB64, message_timestamp);\n\n      // 7. Attach iv (in case backend doesn’t return it)\n      const savedWithIv = {\n        ...saved,\n        iv: ivB64\n      };\n\n      // 8. Decrypt server version (so local temp msg is replaced)\n      const decryptedText = await decryptMessage(savedWithIv);\n      setChannels(prev => prev.map(msg => msg.chatid === localMessage.chatid ? decryptedText : msg));\n\n      // 9. Emit to socket\n      if (socket) socket.emit('newMessage', savedWithIv);\n    } catch (err) {\n      console.error('❌ addMessage backend error:', err);\n    }\n  };\n\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: Mark chat read\r\n     Description: Marks all messages for a donation as read locally and via backend\r\n  */\n  const markChatRead = async donationId => {\n    if (!donationId || !currentUserId || readCache.has(donationId)) return;\n    const hasUnread = channels.some(msg => msg.donationid === donationId && msg.senderid !== currentUserId && !msg.readreceipts);\n    if (!hasUnread) return;\n    readCache.add(donationId);\n    setChannels(prev => prev.map(msg => msg.donationid === donationId && msg.senderid !== currentUserId ? {\n      ...msg,\n      readreceipts: true\n    } : msg));\n    try {\n      await markChatReadService(donationId, currentUserId);\n      if (socket) socket.emit('messageRead', {\n        donationId,\n        senderId: currentUserId\n      });\n    } catch (err) {\n      console.error(' markChatRead backend error:', err);\n    }\n  };\n\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: Mark chat delivered\r\n     Description: Marks all messages for a donation as delivered locally and via backend\r\n  */\n  const markDelivered = async donationId => {\n    if (!donationId || !currentUserId) return;\n    setChannels(prev => prev.map(msg => msg.donationid === donationId && msg.senderid !== currentUserId ? {\n      ...msg,\n      delivered: true\n    } : msg));\n    try {\n      const result = await markDeliveredService(donationId, currentUserId);\n      if (socket) socket.emit('messageDelivered', {\n        donationId,\n        userId: currentUserId\n      });\n      return result;\n    } catch (err) {\n      console.error(' markDelivered backend error:', err);\n    }\n  };\n\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: Unread count helper\r\n     Description: Returns number of unread messages for a donation\r\n  */\n  const getUnreadCount = donationId => {\n    if (!currentUserId) return 0;\n    return channels.filter(msg => msg.donationid === donationId && msg.senderid !== currentUserId && !msg.readreceipts && msg.delivered).length;\n  };\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: {\n      channels,\n      setChannels,\n      markChatRead,\n      markDelivered,\n      addMessage,\n      getUnreadCount,\n      currentUserEmail,\n      currentUserId,\n      socket,\n      onlineUsers\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 332,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatProvider, \"FCqxxo56Ll+yMY10xtCS/xRR7ts=\");\n_c = ChatProvider;\nexport default ChatContext;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","getStakeholderId","getUserChats","markChatRead","markChatReadService","updateChatHistory","markDelivered","markDeliveredService","io","jsxDEV","_jsxDEV","ChatContext","bufToBase64","buf","bytes","Uint8Array","binary","i","byteLength","String","fromCharCode","btoa","base64ToBuf","b64","atob","length","charCodeAt","buffer","encryptWithKey","key","plaintext","iv","crypto","getRandomValues","encoded","TextEncoder","encode","cipherBuffer","subtle","encrypt","name","ciphertextB64","ivB64","keyCache","Map","deriveKey","donationId","has","get","enc","keyMaterial","importKey","salt","iterations","hash","set","ivCache","decryptMessage","msg","console","log","chatid","chathistory","donationid","rawCipher","rawIv","decrypted","decrypt","decryptedText","TextDecoder","decode","err","error","ChatProvider","children","currentUserEmail","currentUserId","initialUserId","_s","channels","setChannels","setCurrentUserId","socket","setSocket","onlineUsers","setOnlineUsers","Set","readCache","response","stakeholderid","newSocket","process","env","REACT_APP_BACKEND_URL","query","userId","emit","on","prev","some","m","map","delivered","senderId","senderid","readreceipts","onlineIds","add","updated","delete","disconnect","off","fetchChats","data","decryptedData","Promise","all","existingIds","newMessages","filter","includes","intervalId","setInterval","clearInterval","addMessage","text","message_timestamp","trim","localMessage","Date","now","saved","savedWithIv","hasUnread","result","getUnreadCount","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/letha/Downloads/EPE Semester Project/foodsave-hub/client/src/communication/Components/ChatContext.jsx"],"sourcesContent":["import React, { createContext, useState, useEffect } from 'react';\r\nimport {\r\n  getStakeholderId,\r\n  getUserChats,\r\n  markChatRead as markChatReadService,\r\n  updateChatHistory,\r\n  markDelivered as markDeliveredService\r\n} from '../services/chatServices';\r\nimport { io } from 'socket.io-client';\r\n\r\n/* Author: Lethabo Mazui\r\n   Event: Sprint 1\r\n   LatestUpdate: Created ChatContext\r\n   Description: Provides context for chat state, encryption, websocket events, and helper functions\r\n*/\r\nconst ChatContext = createContext();\r\n\r\n// ----------------------------\r\n// Base64 helpers\r\n// ----------------------------\r\n/* Author: Lethabo Mazui\r\n   LatestUpdate: Added buf/base64 conversion\r\n   Description: Converts ArrayBuffer to base64 string\r\n*/\r\nfunction bufToBase64(buf) {\r\n  const bytes = new Uint8Array(buf);\r\n  let binary = '';\r\n  for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);\r\n  return btoa(binary);\r\n}\r\n\r\n/* Author: Lethabo Mazui\r\n   LatestUpdate: Added base64 to ArrayBuffer conversion\r\n   Description: Converts base64 string to ArrayBuffer\r\n*/\r\nfunction base64ToBuf(b64) {\r\n  const binary = atob(b64);\r\n  const bytes = new Uint8Array(binary.length);\r\n  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);\r\n  return bytes.buffer;\r\n}\r\n\r\n// ----------------------------\r\n// AES-GCM encryption helpers\r\n// ----------------------------\r\n/* Author: Lethabo Mazui\r\n   LatestUpdate: Added encryptWithKey function\r\n   Description: Encrypts plaintext with AES-GCM using a derived key\r\n*/\r\nasync function encryptWithKey(key, plaintext) {\r\n  const iv = crypto.getRandomValues(new Uint8Array(12));\r\n  const encoded = new TextEncoder().encode(plaintext);\r\n  const cipherBuffer = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, encoded);\r\n  return { ciphertextB64: bufToBase64(cipherBuffer), ivB64: bufToBase64(iv) };\r\n}\r\n\r\n// ----------------------------\r\n// Key derivation\r\n// ----------------------------\r\nconst keyCache = new Map();\r\n/* Author: Lethabo Mazui\r\n   LatestUpdate: Added deriveKey\r\n   Description: Deterministically derives AES-GCM key per donationId\r\n*/\r\nasync function deriveKey(donationId) {\r\n  if (keyCache.has(donationId)) return keyCache.get(donationId);\r\n  const enc = new TextEncoder();\r\n  const keyMaterial = await crypto.subtle.importKey(\r\n    \"raw\",\r\n    enc.encode(donationId),\r\n    \"PBKDF2\",\r\n    false,\r\n    [\"deriveKey\"]\r\n  );\r\n  const key = await crypto.subtle.deriveKey(\r\n    { name: \"PBKDF2\", salt: enc.encode(\"chat-e2ee\"), iterations: 100000, hash: \"SHA-256\" },\r\n    keyMaterial,\r\n    { name: \"AES-GCM\", length: 256 },\r\n    false,\r\n    [\"encrypt\", \"decrypt\"]\r\n  );\r\n  keyCache.set(donationId, key);\r\n  return key;\r\n}\r\n\r\n// ----------------------------\r\n// Decryption helper\r\n// ----------------------------\r\nconst ivCache = new Map();\r\n/* Author: Lethabo Mazui\r\n   LatestUpdate: Added decryptMessage\r\n   Description: Safely decrypts message using cached key + IV\r\n*/\r\nasync function decryptMessage(msg) {\r\n  console.log('Attempting to decrypt message:', msg.chatid);\r\n    console.log('Raw newMessage from server:', msg);\r\n  \r\n  if (!msg.chathistory || !msg.iv || !msg.donationid) {\r\n    console.log('Missing required fields for decryption');\r\n    return { ...msg, chathistory: \"\" };\r\n  }\r\n  \r\n  try {\r\n    let key = await deriveKey(msg.donationid);\r\n    console.log('Key derived for donation:', msg.donationid);\r\n\r\n    if (!ivCache.has(msg.chatid)) ivCache.set(msg.chatid, msg.iv);\r\n    const rawCipher = base64ToBuf(msg.chathistory);\r\n    const rawIv = base64ToBuf(ivCache.get(msg.chatid));\r\n\r\n    console.log('Decrypting with IV:', msg.iv);\r\n    const decrypted = await crypto.subtle.decrypt({ name: \"AES-GCM\", iv: rawIv }, key, rawCipher);\r\n    \r\n    const decryptedText = new TextDecoder().decode(decrypted);\r\n    console.log('Successfully decrypted:', decryptedText);\r\n    \r\n    return { ...msg, chathistory: decryptedText };\r\n  } catch (err) {\r\n    console.error(` Failed to decrypt message ${msg.chatid}:`, err);\r\n    return { ...msg, chathistory: \"[decryption error]\" };\r\n  }\r\n}\r\n\r\n// ----------------------------\r\n// ChatProvider component\r\n// ----------------------------\r\nexport const ChatProvider = ({ children, currentUserEmail, currentUserId: initialUserId }) => {\r\n  const [channels, setChannels] = useState([]);\r\n  const [currentUserId, setCurrentUserId] = useState(initialUserId || null);\r\n  const [socket, setSocket] = useState(null);\r\n  const [onlineUsers, setOnlineUsers] = useState(new Set());\r\n  const readCache = new Set();\r\n\r\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: Fetch stakeholderId\r\n     Description: Determines current userId if not already set\r\n  */\r\n  useEffect(() => {\r\n    if (!currentUserEmail || currentUserId) return;\r\n    (async () => {\r\n      try {\r\n        const response = await getStakeholderId(currentUserEmail);\r\n        if (!response?.stakeholderid) return;\r\n        setCurrentUserId(response.stakeholderid);\r\n      } catch (err) {\r\n        console.error(' Error fetching stakeholderId:', err);\r\n      }\r\n    })();\r\n  }, [currentUserEmail, currentUserId]);\r\n\r\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: WebSocket connection\r\n     Description: Sets up socket.io for real-time messages and online status tracking\r\n  */\r\n  useEffect(() => {\r\n    if (!currentUserId) return;\r\n    const newSocket = io(process.env.REACT_APP_BACKEND_URL, { query: { userId: currentUserId } });\r\n    setSocket(newSocket);\r\n\r\n    newSocket.emit('joinUser', { userId: currentUserId });\r\n\r\n    newSocket.on('newMessage', async (msg) => {\r\n      const decrypted = await decryptMessage(msg);\r\n      setChannels(prev => prev.some(m => m.chatid === msg.chatid) ? prev : [...prev, decrypted]);\r\n    });\r\n\r\n    newSocket.on('messageDelivered', ({ chatid }) => {\r\n      setChannels(prev => prev.map(msg => msg.chatid === chatid ? { ...msg, delivered: true } : msg));\r\n    });\r\n\r\n    newSocket.on('messageRead', ({ donationid, senderId }) => {\r\n      setChannels(prev => prev.map(msg => msg.donationid === donationid && msg.senderid !== senderId ? { ...msg, readreceipts: true } : msg));\r\n    });\r\n\r\n    newSocket.on('onlineUsers', (onlineIds) => setOnlineUsers(new Set(onlineIds)));\r\n    newSocket.on('userConnected', (userId) => setOnlineUsers(prev => new Set(prev).add(userId)));\r\n    newSocket.on('userDisconnected', (userId) => setOnlineUsers(prev => {\r\n      const updated = new Set(prev);\r\n      updated.delete(userId);\r\n      return updated;\r\n    }));\r\n\r\n    return () => {\r\n      newSocket.disconnect();\r\n      newSocket.off('onlineUsers');\r\n      newSocket.off('userConnected');\r\n      newSocket.off('userDisconnected');\r\n    };\r\n  }, [currentUserId]);\r\n\r\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: Polling getUserChats\r\n     Description: Periodically fetches user chats and decrypts messages\r\n  */\r\n  useEffect(() => {\r\n    if (!currentUserEmail || !currentUserId) return;\r\n\r\n    const fetchChats = async () => {\r\n      try {\r\n        const data = await getUserChats(currentUserEmail);\r\n        if (!data?.length) return;\r\n        const decryptedData = await Promise.all(data.map(decryptMessage));\r\n\r\n        setChannels(prev => {\r\n          const existingIds = prev.map(m => m.chatid);\r\n          const newMessages = decryptedData.filter(m => !existingIds.includes(m.chatid));\r\n          return [...prev, ...newMessages];\r\n        });\r\n      } catch (err) {\r\n        console.error(' Polling getUserChats error:', err);\r\n      }\r\n    };\r\n\r\n    fetchChats();\r\n    const intervalId = setInterval(fetchChats, 5000);\r\n    return () => clearInterval(intervalId);\r\n  }, [currentUserEmail, currentUserId]);\r\n\r\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: Add new message\r\n     Description: Encrypts, sends, stores locally, and emits via socket\r\n  */\r\n/* Author: Lethabo Mazui\r\n   LatestUpdate: Fixed IV handling in addMessage\r\n   Description: Derives key, encrypts once, attaches IV, and syncs with backend\r\n*/\r\nconst addMessage = async (senderId, text, donationId, message_timestamp) => {\r\n  if (!donationId || !senderId || !text.trim()) return;\r\n\r\n  try {\r\n    // 1. Derive key first\r\n    const key = await deriveKey(donationId);\r\n\r\n    // 2. Encrypt message (ciphertext + iv)\r\n    const { ciphertextB64, ivB64 } = await encryptWithKey(key, text);\r\n\r\n    // 3. Create temporary local message (shows instantly in UI)\r\n    const localMessage = {\r\n      chatid: `temp-${Date.now()}`,\r\n      donationid: donationId,\r\n      senderid: senderId,\r\n      chathistory: text,   // plain text for local display\r\n      iv: ivB64,           // include generated IV immediately\r\n      message_timestamp,\r\n      readreceipts: false,\r\n      delivered: false\r\n    };\r\n\r\n    // 4. Cache the IV for this chatid\r\n    ivCache.set(localMessage.chatid, ivB64);\r\n\r\n    // 5. Add localMessage to UI immediately\r\n    setChannels(prev => [...prev, localMessage]);\r\n\r\n    // 6. Save encrypted message to backend\r\n    const saved = await updateChatHistory(\r\n      donationId,\r\n      senderId,\r\n      ciphertextB64,\r\n      ivB64,\r\n      message_timestamp\r\n    );\r\n\r\n    // 7. Attach iv (in case backend doesn’t return it)\r\n    const savedWithIv = { ...saved, iv: ivB64 };\r\n\r\n    // 8. Decrypt server version (so local temp msg is replaced)\r\n    const decryptedText = await decryptMessage(savedWithIv);\r\n\r\n    setChannels(prev =>\r\n      prev.map(msg =>\r\n        msg.chatid === localMessage.chatid ? decryptedText : msg\r\n      )\r\n    );\r\n\r\n    // 9. Emit to socket\r\n    if (socket) socket.emit('newMessage', savedWithIv);\r\n\r\n  } catch (err) {\r\n    console.error('❌ addMessage backend error:', err);\r\n  }\r\n};\r\n\r\n\r\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: Mark chat read\r\n     Description: Marks all messages for a donation as read locally and via backend\r\n  */\r\n  const markChatRead = async (donationId) => {\r\n    if (!donationId || !currentUserId || readCache.has(donationId)) return;\r\n\r\n    const hasUnread = channels.some(msg => msg.donationid === donationId && msg.senderid !== currentUserId && !msg.readreceipts);\r\n    if (!hasUnread) return;\r\n\r\n    readCache.add(donationId);\r\n    setChannels(prev => prev.map(msg => msg.donationid === donationId && msg.senderid !== currentUserId ? { ...msg, readreceipts: true } : msg));\r\n\r\n    try {\r\n      await markChatReadService(donationId, currentUserId);\r\n      if (socket) socket.emit('messageRead', { donationId, senderId: currentUserId });\r\n    } catch (err) {\r\n      console.error(' markChatRead backend error:', err);\r\n    }\r\n  };\r\n\r\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: Mark chat delivered\r\n     Description: Marks all messages for a donation as delivered locally and via backend\r\n  */\r\n  const markDelivered = async (donationId) => {\r\n    if (!donationId || !currentUserId) return;\r\n    setChannels(prev => prev.map(msg => msg.donationid === donationId && msg.senderid !== currentUserId ? { ...msg, delivered: true } : msg));\r\n    try {\r\n      const result = await markDeliveredService(donationId, currentUserId);\r\n      if (socket) socket.emit('messageDelivered', { donationId, userId: currentUserId });\r\n      return result;\r\n    } catch (err) {\r\n      console.error(' markDelivered backend error:', err);\r\n    }\r\n  };\r\n\r\n  /* Author: Lethabo Mazui\r\n     LatestUpdate: Unread count helper\r\n     Description: Returns number of unread messages for a donation\r\n  */\r\n  const getUnreadCount = (donationId) => {\r\n    if (!currentUserId) return 0;\r\n    return channels.filter(msg => msg.donationid === donationId && msg.senderid !== currentUserId && !msg.readreceipts && msg.delivered).length;\r\n  };\r\n\r\n  return (\r\n    <ChatContext.Provider value={{\r\n      channels,\r\n      setChannels,\r\n      markChatRead,\r\n      markDelivered,\r\n      addMessage,\r\n      getUnreadCount,\r\n      currentUserEmail,\r\n      currentUserId,\r\n      socket,\r\n      onlineUsers\r\n    }}>\r\n      {children}\r\n    </ChatContext.Provider>\r\n  );\r\n};\r\n\r\nexport default ChatContext;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}